---
output:
  md_document:
    variant: markdown_github
---

# Roadmap

The goal is to assess the performance of dividend yield as an investment strategy. I plan to use optimized portfolios of the highest paying dividend stock and/or highest growth in dividends for a group of assets. However, first I want to calculate all cumulative returns for all indexes and their benchmarks. 

##  Approach to Use

Passive equity investment offers transparent, investable and a rules-based approach, avoiding the need to identify mispriced securities commonly associated with active portfolio construction. Before we build our own portfolios I will compare performance indexes against their benchmarks across the globally.

I will present this in tabular form showing a comparison between index and benchmark. 

After this I will build global dividend portfolios by sector and assess whether there performance offers superior excess return over the generic geographical option that we often see practitioners construct. 

# Instruments 

```{r Instruments, echo=TRUE, message=FALSE, warning=FALSE}
library(knitr)
Table_data <- readxl::read_xlsx("data/Systematic Indices and Benchmarks.xlsx")
knitr::kable(Table_data) 
```

# Portfolios  

```{r Cumulative Return, echo=FALSE, message=FALSE, warning=FALSE}
pacman::p_load("xts", "tidyverse", "tbl2xts", "PerformanceAnalytics", 
               "lubridate", "glue")
library(tbl2xts)
library(tidyverse)
library(xts)

# Load the data 

raw.indexes <- readxl::read_xlsx("data/Benckmarks.xlsx")

# Tidy the data and get simple returns

simple_return <- raw.indexes %>%
  arrange(Date) %>%
  filter(Date >= lubridate::ymd(20140102)) %>%
  gather(key = Index, value = Price, -Date) %>% 
  group_by(Index) %>%
  mutate(across(.cols = Price, .fns = ~./lag(.), .names = "{.col}_return")) %>% 
  select(Date, Index, Price_return)
  
#  Graph it to see if everything is in order
ggplot(simple_return, aes(x = Date, y = Price_return, group = Index)) +
  geom_line() +
  facet_wrap(~ Index) +
  labs(x = "Date", y = "Price Return", title = "Price Returns for Indexes") +
  theme_minimal() +
  theme(legend.position = "none")

# Cum returns 

Cum_returns <- simple_return %>% 
  filter(Date>first(Date)) %>%
  mutate(DaliyIndex = cumprod(1 + Price_return), YM = format(Date, "%B_%y")) %>% 
  group_by(YM) %>% 
  filter(Date==last(Date)) %>%
  ungroup() %>% 
  select(Date, Index, DaliyIndex)

```

